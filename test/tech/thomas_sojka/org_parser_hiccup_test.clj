(ns tech.thomas-sojka.org-parser-hiccup-test
  (:require [clojure.string :as str]
            [clojure.test :as t]
            [hiccup2.core :as hiccup]
            [tech.thomas-sojka.org-parser-hiccup :as sut]))

(defn html-str [org-path]
  (->> (sut/parse org-path)
       (map (fn [el] (hiccup/html el)))
       str/join))

(t/deftest parse-to-html
  (t/testing "Setup tests with Cider"
    (t/is (= (html-str "content/setup-tests-with-cider-and-depsedn-in-5-steps.org")
             "<h1>Setup tests with Cider &amp; deps.edn in 5 steps</h1><h2><a href=\"https://github.com/rollacaster/setup-tests-with-cider\">The Gist</a></h2><h3>1. Setup  project structure</h3><h4>File structure</h4><pre>   .\n   ‚îú‚îÄ‚îÄ deps.edn\n   ‚îî‚îÄ‚îÄ src\n       ‚îî‚îÄ‚îÄ your_group\n           ‚îî‚îÄ‚îÄ your_project\n               ‚îî‚îÄ‚îÄ core.clj</pre><h4>deps.edn file</h4><pre> {:deps {org.clojure/clojure {:mvn/version &quot;1.10.1&quot;}}\n  :paths [&quot;src&quot; &quot;resources&quot;]}</pre><h3>2. Write test</h3><h4>File structure</h4><pre>  .\n  ‚îú‚îÄ‚îÄ deps.edn\n  ‚îú‚îÄ‚îÄ src\n  ‚îÇ   ‚îî‚îÄ‚îÄ your_group\n  ‚îÇ       ‚îî‚îÄ‚îÄ your_project\n  ‚îÇ           ‚îî‚îÄ‚îÄ core.clj\n  ‚îî‚îÄ‚îÄ test\n      ‚îî‚îÄ‚îÄ your_group\n          ‚îî‚îÄ‚îÄ your_project\n              ‚îî‚îÄ‚îÄ core_test.clj</pre><h4>Test file</h4><pre>  (ns your-group.your-project.core-test\n    (:require [clojure.test :refer [deftest is]]))\n\n  (deftest core-test\n    (is (= 2 (+ 1 1))))</pre><h3>3. Add <code>:test</code> alias to <code>deps.edn</code> </h3><h4>deps.end file</h4><pre>  {:deps {org.clojure/clojure {:mvn/version &quot;1.10.1&quot;}}\n   :paths [&quot;src&quot; &quot;resources&quot;]\n   :aliases {:test {:extra-paths [&quot;test&quot;]}}} ;; &lt;- test alias</pre><h3>4. Add dir local variable for jack-in</h3><h4>File structure</h4><pre>.\n‚îú‚îÄ‚îÄ deps.edn\n‚îú‚îÄ‚îÄ .dir-locals.el &lt;-- added\n‚îî‚îÄ‚îÄ src/..</pre><h4>.dir-locals.el file</h4><pre>((clojure-mode . ((cider-clojure-cli-global-options . &quot;-M:test&quot;))))</pre><h3>5. Run tests</h3><p><code>C-c C-t l</code> or =M-x cider-test-run-loaded-tests=</p><h2>Setup tests with Cider &amp; deps.edn in 5 steps</h2><p>Based on <a href=\"https://practicalli.github.io/spacemacs/testing/unit-testing/cider-test-deps-edn-projects.html\">Clojure development with Spacemacs &amp; Cider</a>, <a href=\"https://clojureverse.org/t/how-to-setup-deps-edn-project-with-cider/6375\">How to setup deps.edn project with cider</a> and some further resources, this is my summary to setup your tests.</p><h3>1. Setup  project structure</h3><p>One thing I like about <a href=\"https://clojure.org/guides/deps_and_cli\">deps.edn</a> is that creating a new project does not need a bootstrapping command, you just create a <a href=\"https://clojure.org/guides/deps_and_cli\">deps.edn</a> file and your source files.</p><blockquote><p><b>Hint:</b> To avoid learning the <a href=\"https://clojure.org/guides/deps_and_cli\">deps.edn</a> file structure by heart, you can use <a href=\"https://github.com/rollacaster/.emacs.d/blob/master/snippets/clojure-mode/depsedn\">a snippet</a>. After the creation of the <a href=\"https://clojure.org/guides/deps_and_cli\">deps.edn</a> file run <code>M-x cider-jack-in-clj</code> and then <code>M-x cljr-add-project-dependency</code> to add any dependencies.</p></blockquote><h4>File structure</h4><pre>  .\n  ‚îú‚îÄ‚îÄ deps.edn\n  ‚îî‚îÄ‚îÄ src\n      ‚îî‚îÄ‚îÄ your_group\n          ‚îî‚îÄ‚îÄ your_project\n              ‚îî‚îÄ‚îÄ core.clj</pre><h4>deps.edn file</h4><pre>{:deps {org.clojure/clojure {:mvn/version &quot;1.10.1&quot;}}\n :paths [&quot;src&quot; &quot;resources&quot;]}</pre><h3>2. Write tests</h3><p>To add a new test, create your test folders and test file according to this structure:</p><h4>File structure</h4><pre>  .\n  ‚îú‚îÄ‚îÄ deps.edn\n  ‚îú‚îÄ‚îÄ src\n  ‚îÇ   ‚îî‚îÄ‚îÄ your_group\n  ‚îÇ       ‚îî‚îÄ‚îÄ your_project\n  ‚îÇ           ‚îî‚îÄ‚îÄ core.clj\n  ‚îî‚îÄ‚îÄ test\n      ‚îî‚îÄ‚îÄ your_group\n          ‚îî‚îÄ‚îÄ your_project\n              ‚îî‚îÄ‚îÄ core_test.clj</pre><p>This follows the advice from <a href=\"https://guide.clojure.style/#testing\">The Clojure Style Guide - Testing</a> to have a separate <code>test</code> directory.</p><h4>Test file</h4><pre>  (ns your-group.your-project.core-test\n    (:require [clojure.test :refer [deftest is]]))\n\n  (deftest core-test\n    (is (= 2 (+ 1 1))))</pre><p><a href=\"https://clojure.github.io/clojure/clojure.test-api.html\">clojure.test</a> is part of Clojure, you do not need any additional dependency.</p><h3>3. Add <code>:test</code> alias to <code>deps.edn</code> </h3><h4>deps.edn file</h4><pre>    {:deps {org.clojure/clojure {:mvn/version &quot;1.10.1&quot;}}\n     :paths [&quot;src&quot; &quot;resources&quot;]\n     :aliases {:test {:extra-paths [&quot;test&quot;]}}} ;; &lt;- test alias</pre><p>This adds an alias to your project. An alias is a shortcut to adjust your <a href=\"https://clojure.org/guides/deps_and_cli\">deps.edn</a> file. In this example we add <code>extra-paths</code> to our <code>classpath</code>. Since we add <code>extra-paths</code> for our tests we can exclude them from deployments. There is nothing special about the added path <code>test</code>, it is just a folder we want to be able to condtionally add or remove from our <code>classpath</code>.</p><h3>4. Add dir local variable for jack-in</h3><p>During development we want to make sure that our tests are available so we want to use our alias to include the <code>test</code> directory. When using <a href=\"https://cider.mx\">Cider</a> you typically run a project with <code>cider-jack-in</code>. It is possible to add a default alias for all calls to <code>cider-jack-in</code> by setting <code>cider-clojure-cli-global-options</code>. You probably want to have different settings per project and you can use <a href=\"https://www.gnu.org/software/emacs/manual/html_node/elisp/Directory-Local-Variables.html\">Directory Local Variables</a> to achieve that. You create a <a href=\"https://www.gnu.org/software/emacs/manual/html_node/elisp/Directory-Local-Variables.html\">Directory Local Variable</a> by creating a <code>.dir-locals.el</code> file in your project root.</p><h4>File structure</h4><pre>.\n‚îú‚îÄ‚îÄ deps.edn\n‚îú‚îÄ‚îÄ .dir-locals.el &lt;-- added\n‚îî‚îÄ‚îÄ src/..</pre><p>This file will set the <code>cider-clojure-cli-global-options</code> variable whenever <code>clojure-mode</code> is active:</p><h4>.dir-locals.el file</h4><pre>((clojure-mode . ((cider-clojure-cli-global-options . &quot;-M:test&quot;))))</pre><blockquote><p><b>Hint</b>: A <a href=\"https://www.gnu.org/software/emacs/manual/html_node/elisp/Directory-Local-Variables.html\">Directory Local Variable</a> is only read when you revoke your buffer, so make sure to revoke your buffer manually with <code>M-x revert-buffer</code> if it was already open when you created <code>.dir-locals.el</code>. Otherwise the variable will not be read.</p></blockquote><h3>5. Run tests</h3><p>In the documententation of <a href=\"https://cider.mx\">Cider</a> you can find <a href=\"https://docs.cider.mx/cider/1.0/testing/running_tests.html\">several fine-grained commands</a> to control which test case should run. To run all loaded tests in your project you can run <code>M-x cider-test-run-loaded-tests</code> or use the shortcut <code>C-c C-t l</code>.</p><h3>Conclusion</h3><p>Setting up tests with <a href=\"https://cider.mx\">Cider</a> &amp; <a href=\"https://clojure.org/guides/deps_and_cli\">deps.edn</a> involves quite many steps due to the flexibility this setup offers. I hope with this blog post, you can configure your first tests faster than I did. You can find <a href=\"https://github.com/rollacaster/setup-tests-with-cider\">the source of this minimal example on github</a>.</p>")))

  (t/testing "Real-life use cases for CLJS macros"
    (t/is (= (html-str "content/real-life-use-cases-for-cljs-macros.org")
             "<h1>Real-life use cases for CLJS macros</h1><p>When I first learned about macros, I immediately recognized how powerful they are. This realization was quickly followed by not having any idea what to build with them. Of course, <a href=\"https://clojure.github.io/clojure/clojure.core-api.html\">clojure.core</a> uses macros, so you can learn how threading or conditionals work. Plus, most articles about macros include some common examples. But without any use case for any of my projects, I quickly forgot macros. While writing <a href=\"https://clojure.org/\">Clojure</a> in the last two years, I never used them. Recently this changed while building <a href=\"https://rollacaster.github.io/hiccup-d3/\">hiccup-d3</a>. I finally found three use cases in which macros are incredibly helpful, so I want to share them.</p><h2>What is hiccup-d3</h2><p>The data viz library <a href=\"https://d3js.org/\">D3</a> is incredibly versatile, but for me, its API is hard to remember. Usually, I start a new data viz by copying an example from <a href=\"https://observablehq.com/\">Observable</a>. Afterward, I translate it to <a href=\"https://clojurescript.org/\">CLJS</a>, then dig into the docs to learn (or relearn) the API. This process takes time, so I decided to speed it up.</p><p>That&apos;s how the idea for <a href=\"https://rollacaster.github.io/hiccup-d3/\">hiccup-d3</a> came into my mind. I wanted to provide a snippets gallery of visualizations coded with CLJS. To start a new data viz, you copy a snippet. In addition, I wanted to ensure that API docs are easily accessed.</p><h2>Use case 1: code deduplication</h2><p>My friend Ricco looked at the first version of the code and noticed an opportunity to write his first macro. Each data viz duplicates the code to run the data viz and to display the code as a snippet. He opened a PR which allowed him to write this code only once. It worked great and saved a lot of code which motivated me to learn more about macros.</p><pre>  (defmacro build-chart [{:keys [title data code]}]\n    `{:title ~title\n      :data  ~data\n      :chart ~code ;; &lt;- executed code\n      :code  &apos;~(last code)}) ;; &lt;- code used for display</pre><p>I reread everything I once learned about macros. Among others, the macros tutorials from three great books. I can recommend each one: <a href=\"https://www.braveclojure.com/\">Clojure for the Brave and True</a>, <a href=\"https://pragprog.com/titles/shcloj3/programming-clojure-third-edition/\">Programming Clojure</a>, <a href=\"https://pragprog.com/titles/roclojure/getting-clojure/\">Getting Clojure</a>.</p><h2>Use case 2: doc links</h2><p>After this refresher of my macro knowledge, new use cases started to pop up. As already mentioned, I have a hard time remembering the <a href=\"https://d3js.org/\">D3</a> syntax. I wanted to include a link to the docs for each D3 API I called in my snippets.</p><p>The easy but cumbersome approach would have been to copy/paste the links into my snippets. A lot of manual work for each snippet. Instead, I wanted to analyze the code and generate a link for each used API. Once more, macros did the job. The macro searches each API call that accesses the <code>d3</code> alias in the snippet. Then, the macro reads the current <a href=\"https://github.com/d3/d3/blob/main/API.md\">D3 API doc</a> from GitHub. For each API call, I extract the link from the <a href=\"https://github.com/d3/d3/blob/main/API.md\">D3 API doc</a>. That is possible because the macro allows me to walk through the code of my snippet. Plus, macro expansion happens at the build time. That means there is no performance penalty for dynamically searching for the links when opening the page.</p><pre>  (defmacro build-chart [title code]\n    `{:title ~title\n      :d3-apis ~(mapv\n                 (fn [fn] {:doc-link (d3-doc-link fn) ;; &lt;- create links from gh-docs\n                         :fn fn})\n                 (d3-fns code)) ;; &lt;- walks through code to find d3 calls\n      :chart (fn [data#] (~code data#))})</pre><p>Without macros, I probably would have never implemented this feature. Maintaining all API links would be too much work.</p><p><img alt=\"A snippet from hiccup-d3 with links to the used D3 APIs.\" src=\"images/hiccup-d3-d3-apis.png\" /></p><h2>Use case 3: syntax highlighting</h2><p>The last feature I wanted to implement was syntax highlighting. Another use case involving code analysis. Thus I needed to access my code and needed a macro. The goal is to specify the type of each expression (for example string, variable, symbol) and apply the styling information. I found the library <a href=\"https://github.com/venantius/glow\">glow</a> that does the work for me. Although <a href=\"https://github.com/venantius/glow\">glow</a> itself is not using any macros, I wrote a macro that wraps all the glow calls and provides my code to glow. Once more macro expansion happens at build time when you open hiccup-d3, all styling information is already in place.</p><pre>  (defmacro build-chart [title code]\n    `{:title ~title\n      :code-formatted ~(glow/highlight-html ;; &lt;- glow is called in macro\n                        (with-out-str (pprint (last code))))\n      :chart (fn [data#] (~code data#))})</pre><p>The result is a well-formatted code snippet with color highlighting, which makes reading and understanding easier. Again, macros improve the performance without much effort at build time.</p><p><img alt=\"A snippet from hiccup-d3 with syntax highlighting applied.\" src=\"images/hiccup-d3-formatted-code.png\" /></p><h2>Conclusion</h2><p>This post is full of praise for the power of macros. But the rule of macros is still: don&apos;t use macros. If you can build something using functions, prefer this approach. I spent two years writing Clojure and never needed a macro. That was good. Learning macros is hard. It&apos;s easy to make mistakes. The article <a href=\"https://www.braveclojure.com/writing-macros/\">Writing Macros</a> contains examples of typical fallacies when writing macros. I stumbled upon all of them while writing my first macro.</p><p>Don&apos;t feel bad if you learn about macros and have no clue when to use them. I guess it&apos;s natural that it takes some time until you can spot the right use cases for macros. I hope my examples could reduce this time for you. So you&apos;ll be proficient with macros in less than two years.</p>")))

  (t/testing "Now"
    (t/is (= (html-str "content/now.org")
             "<h1>Now</h1><h2>Contributing to Open Source in Clojure</h2><p>I started to contribute to <a href=\"https://cljdoc.org/\">cljdoc</a>. I am leveling my Clojure skills by doing so. I am proud of some minor additions I finished and excited for my future contributions.</p><h2>Learning Datomic</h2><p>My grocery application <a href=\"https://github.com/rollacaster/shopping-cards\">shopping-cards</a> is turning into a playground to explore new technologies for me. After adding re-frame to the Frontend, I am migrating the data from files to <a href=\"https://docs.datomic.com/cloud/dev-local.html\">Datomic Local Dev</a>.</p><h2>Generative art</h2><p>For my 30th birthday, I got an Axidraw. I am using it to stick little pieces of art all over my office. I have completed five so far and hope to fill the entire wall.</p><h2>Reading!</h2><p>At the end of last year, I started to read Structure and interpretation of computer programs. I try to solve each exercise for 30 minutes. I make slow progress, but progress.</p>")))

  (t/testing "Learning Clojure"
    (t/is (= (html-str "content/learning-clojure.org")
             "<h1>Learning Clojure</h1><p>One of my good intentions this year is to learn a new programming language. Choosing between the various options proved to be a difficult task. I tried to choose between PureScript, Clojure and Reason ML. In the end the article about the <a href=\"http://blog.cognitect.com/blog/2017/1/31/clojure-2018-results\">State of Clojure in 2018</a> was the decisive factor. 50% of all respondents were Emacs users and since my latest <a href=\"https://github.com/rollacaster/elcontext\">shenanigans with Emacs Lisp</a> I was sold with lisp anyway.</p><p>If you search for Clojure learning resources most roads lead to <a href=\"https://www.braveclojure.com/\">BRAVE CLOJURE</a>, an excellent book introducing Clojure. Thanks to this book I will skip the Clojure basics in this post (just read the book üòâ) and start with my Clojure journey right after finishing the book.</p><p>When I look back on how I learned other programming languages, I always regret that I didn‚Äôt read enough code from other people. Especially in my main language, JavaScript, I feel uncomfortable reading library code on github. This has changed for me with Clojure and I think this is due to Lisp‚Äôs minimal syntax approach. There is less personal style involved when reading other Clojure code besides <code>(some-fn some-args)</code> thus there are not that many other options to write your code or at least less options than in JavaScript.</p><p>I started my Clojure journey by finding some relevant libraries and skimming through the code these libraries included:</p><ul><li>core-async</li><li>reagent</li><li>re-frame</li><li>ring</li><li>compojure</li><li>nrepl</li><li>figwheel</li><li>leiningen</li><li>secretary</li></ul><p>I haven‚Äôt read every library thoroughly, but just enough to get the general implementation of the library and learn some new tricks with Clojure.</p><p>I started my first Clojure project a shareable shopping list which is still work in progress. After my initial Clojure honeymoon phase the first issues arose. There are many different profiles to bootstrap your application with <code>leiningen</code> but it was difficult to adjust anything with the predefined setups. Every time I fixed a problem with my setup, I created a new one. In the end I removed most of the code from the profile and did the dev setup myself, which took some time, but now everything works as expected.</p><p>In general I think it was a good choice to learn Clojure, the interactive development approach with Clojure‚Äôs REPL allows short feedback loops when developing an application. In addition you notice the long design phase of Clojure most of core methods are composable and intuitive to use. I hope more blog posts about Clojure will follow soon.</p>" )))

  (t/testing "6 Tips to finish your Side Project"
    (t/is (= (html-str "content/6-tips-to-finish-your-side-project.org")
             "<h1>6 Tips to finish your Side Project</h1><p>I fail to finish about 60% of my side projects but recently I finished six projects in a row. This article explains how I did this.</p><p>In the last five years I started 41 side projects and only finished 17. To me, finishing a side project means that I successfully executed my idea and after that I published it  by writing a blog about it or if I built something for another person and I send it to this person.</p><p>As you can see in the chart below lately my success rate peaked, so I reflected about recent changes how I approached my side projects.</p><picture>  <source media=\"(max-width: 799px)\" srcset=\"images/side-projects.svg\">  <source media=\"(min-width: 800px)\" srcset=\"images/side-projects-lg.svg\">  <img src=\"images/side-projects.png\" alt=\"Chart displaying all my succeeded/failed side projects\"></picture><p>I identified 6 tips which could help you too. Of course, these tips are representing my journey and not all of them will work you. Try to pick one or two and test for yourself whether they can help you.</p><h3>Tips</h3><h4>Stop when it&apos;s fun</h4><p>Here&apos;s something that happens regularly to me: I finish a challenging task and I am so excited about it that I tackle the next one immediately. I avoid this now because what usually happens is that I fail to finish the next task. I guess it happens because I didn&apos;t notice being exhausted after finishing the challenging task. Then, after I failed the next task I have to stop working being frustrated which makes it harder to get back to it.</p><p>Instead, now I stop working after successfully finishing a task. This way I stop with a good feeling and I am curious to start the next task which makes it easy to continue with the project.</p><h4>Prototype early &amp; often</h4><p>After you finished your first task you should immediately think about publishing it, even if it&apos;s just a &apos;Hello World&apos;. Start to build a minimal Deployment Pipeline which allows you to share the current state of your project. Even if your project looks boring in the beginning take some screenshots so that you continuously see your progress.</p><p>If your side project is an application hosted on the web, https://vercel.com is a great way to setup your deployment pipeline within a few  minutes.</p><h4>Plan 2-4 steps ahead</h4><p>Deciding completely independent what to do next is my greatest joy when working on a side project. But with great power comes great responsibility. It happened quite often that I lost focus of my overall goal. I spend too much time with details without any major progress. This usually results in an unfinished side project.</p><p>To avoid this I always maintain a list with 2-4 next steps. Each step is so small that it takes about half an hour. Planning not too far ahead helps to balance between spontaneously adjusting your project to new ideas while focusing on your main goal.</p><h4>Track your time</h4><p>I started to track the time of each task I do. This helps me to notice when I am stuck and allows me to change my plan. For instance, if I notice I tried to solve a task for more than 30 minutes without any progress, it&apos;s worth thinking about other approaches. In addition, it&apos;s really interesting to know how much time you spent with your side project and you continuously get better at estimating how much time you need to realize new ideas. For instance writing this blog including the creation of the data visualisation above took me about 7 hours.</p><p>I am using <a href=\"https://orgmode.org/manual/Clocking-Work-Time.html\">Org Mode&apos;s Clocking Feature</a> to track my time but I am sure there are plenty of tools which can help you to track your time which are not dependent on a certain editor. Unfortunately I do not know any other tools.</p><h4>Do multiple side projects at once</h4><p>I am sure this tip does not work for everyone but it helped me a lot. I usually have 2-4 side projects at once and I work on 1-2 of them each day for about half an hour. I am sure there are people who need to focus on one topic to be productive. For me, if I try to work on the same thing each day it gets boring. It&apos;s probably best to find your own way by trying different approaches.</p><h4>Take your time</h4><p>Even if you follow all of the tips and read through many other great resources about this topic there is nothing more valuable than gathering your own experiences. It took me five years and 41 projects until I found a workflow which seems to work for me. Hopefully my tips can help you reach this goal quicker than I did.</p><p>If you have any other tips which help to finish a side project please reach out: <a href=\"https://mobile.twitter.com/rollacaster\"></a></p>")))

  (t/testing "100 Days of Spaced Repetition"
    (t/is (= (html-str "content/100-days-of-spaced-repetition.org")
             "<h1>100 Days of Spaced Repetition</h1><p>100 days ago I was introduced to Spaced Repetition, a learning method scientifically proven to work. The basic idea is to learn facts and repeat them at increasing intervals. After several iterations, you remember the fact forever.</p><p><img alt=\"file:~/projects/thomas-sojka-tech/src/images/spaced-repetition.png\" src=\"images/spaced-repetition.png\" /></p><p>I was introduced to Spaced Repetition by reading <a href=\"https://ncase.me/remember/\">How To Remember Anything Forever-ish</a> by Nicky Case. It is a great introduction because you will begin your Spaced Repetition adventure while you are still reading. After you finish the article you will know what Spaced Repetition is, how it works, why it works and you will have completed your first session.</p><p>In this article, I want to share my experience 100 days after reading the article and I can say this much in advance: you really should try it yourself.</p><h2>Why I thought Spaced Repetition is a bad idea ü§î</h2><p>Although I immediately started with Spaced Repetition after reading the article, I had some doubts about whether it was really useful. There is simply no need to memorize everything when you have a smartphone in your pocket with all possible facts only fingertips away. Still, I wanted to try it for a few weeks, learning 10 facts a day. This was enough to change my mind.</p><h2>Which benefits changed my mind  ü§Ø</h2><h3>Staying in the flow ‚åõ</h3><p>I work as a programmer and need to remember many function names. With Spaced repetition instead of opening a browser and google for a function name, I can create a new fact each time I forget one. After some time I can stay in the flow of my current work for a long time.</p><p>Besides function names, other things interrupt my workflow, such as forgetting mathematical conversions or having to recalculate constants (e.g. how many seconds are in a day). I am sure that in every profession there is some information that you constantly recheck and getting rid of this is a soothing experience.</p><h3>Keep valuable knowledge üóùÔ∏è</h3><p>Before I did Spaced Repetition I felt that all that mattered was knowing where to find information and that keeping it all in your memory was bad because of limited memory space. I still think that for some information it is bad to keep them in your memory, e.g. unfinished tasks that you are afraid of forgetting should be written down immediately because a lot of stress vanishes when you note them down. But while it&apos;s stressful to keep certain information in your brain, I no longer feel like memory space is limited in any way. As long as you memorize new things at a steady and fairly slow pace, it feels like you can go on forever.</p><p>I also noticed another change. Whenever I read something, I am constantly searching for relevant facts I can use for Spaced Repetition in the back of my mind. This makes my readings more valuable because I can be sure not to forget anything important and scanning texts for relevant facts helps me to better understand the text itself.</p><h3>Think outside the box üì¶</h3><p>There are some topics that I deem important to know but have always been too lazy to learn. For example, how my country&apos;s political system works, understanding the effects of global warming in concrete numbers, or current relevant events like understanding how the Covid-19 vaccine works.</p><p>These topics or pretty much any topic where I have no prior knowledge or forgotten everything I learned in school would have been intimidating to learn for me. Now, with Spaced Repetition I can learn those topics slowly e.g. by starting with three definitions about the topic and building up upon those facts which seems less scary to me. Learning new subjects slowly is much easier for me and I take pride in acquiring the knowledge I think is important.</p><h2>What surprised me in the last 100 days üòÆ</h2><p>My daily recap time is not constantly increasing. I expected that as I added more facts per day, it would take me more and more time to recap my facts. But currently it takes me about 15-20 minutes each day and it&apos;s not getting any longer.</p><p>Boring facts are hard to remember. Whenever I have trouble remembering a fact, I realize that the fact is not interesting to me anymore. It&apos;s really important to add facts that interest you to facilitate learning.</p><p>One thing which was frustrating at times was finding the material for my 10 daily facts. This struggle felt like a constant rollercoaster, in the beginning, it was easy and sometimes I would prepare more than 10 facts and be able to save them for the next day. Other days, I would spend 40 minutes and end up with new facts that I wasn&apos;t interested in. I am confident I will improve and hopefully my blog post &quot;A Year of Spaced Repetition&quot; will be full of good advice on how to find facts that are relevant to you.</p><p>Another surprise was my renewed interest in old topics which had not interested me for a while. I studied information systems, which is a mixture of computer science and economics, but after university, I became completely immersed in programming and haven&apos;t learned anything related to economics in years. With Spaced Repetition, it was easy to get back into it because I could relearn it in small steps, which was is a nice experience.</p><p>At the end of <a href=\"https://ncase.me/remember/\">How To Remember Anything Forever-ish</a> was a link to <a href=\"https://www.supermemo.com/en/archives1990-2015/articles/20rules\">Effective learning: Twenty rules of formulating knowledge</a> and this post keeps what it promises. After learning how to properly formulate my facts, learning became easier. But I would advise against reading it when you&apos;re just starting with Spaced Repetition. In the beginning, forming a habit is much more important than proper technique but you should save this link and read it a few weeks later.</p><h2>What I learned üí°</h2><p>I&apos;d like to share with you the areas I have learned new facts in to give you some ideas for your learning journey. Of course, each journey is different and ultimately everyone has to find their own path but those categories might help you discover some areas of interest.</p><h3>Order of magnitudes ‚öñÔ∏è</h3><p>Sometimes I read about a number and I cannot interpret it because I lack the context to understand it. What I try to do now is to learn some numbers of certain areas e.g. revenue:</p><ul><li>What&apos;s the revenue of Apple?</li><li>What&apos;s the revenue of BMW?</li><li>What&apos;s the revenue of Spotify?</li></ul><p>After learning these numbers, whenever someone tells me the revenue of a new company, I can compare it and understand if this number is high or low. Some other magnitudes that I learned this way:</p><ul><li>Data processing speed</li><li>Internet speed</li><li>Planet sizes</li><li>GDP of countries</li><li>Areas of countries</li></ul><h3>Current job üë®‚Äçüíª</h3><p>I have worked as a programmer for five years and studied information systems before that. That&apos;s plenty of time to forget a lot of the basics I learned at university but Spaced repletion allowed me to recap:</p><ul><li>Data structures and how they work</li><li>Algorithms and how they work</li><li>Which subfields there are in computer science</li><li>The winners of the Turing Award</li></ul><h3>New job areas üìä</h3><p>For me, data visualization is an area where I want to dive further and I have been using Spaced Repetition to learn the basics:</p><ul><li>What kind of data visualizations exist?</li><li>What are the advantages/disadvantages of certain data visualizations?</li><li>What are the key principles to create a data visualization?</li></ul><h3>Books üìö</h3><p>Books are full of knowledge worth keeping and it&apos;s always sad when that knowledge fades away after some years. With Spaced Repetition you can stop this. I have summarized facts from:</p><ul><li>The pragmatic programmer</li><li>Refactoring UI</li><li>Drive</li><li>The 7 habits of highly effective people</li><li>Conversationally speaking</li><li>To Sale is Human</li></ul><h3>General and recent knowledge ü§ì</h3><p>By starting with minor facts learning doesn&apos;t feel overwhelming anymore. This way</p><p>There are so many things that I always thought I should know, but starting to learn those felt overwhelming. By starting with minor facts learning doesn&apos;t feel overwhelming anymore. This way I learned:</p><ul><li>The effects of climate change</li><li>How Covid-19 vaccination works</li><li>How the German and European political systems works</li></ul><h2>Conclusion üéá</h2><p>I am looking forward to the next 100 days of Spaced Repetition and I am curious if I am going to use it differently than I am using it now. I hope this article got you some ideas about why you should use Spaced Repetition. If you&apos;re already using it maybe you found some inspiration about additional things to learn.</p><p>I would be happy to receive feedback or ideas about this topic. You can contact me by <a href=\"mailto:contact@thomas-sojka.tech\">mail</a> or <a href=\"https://mobile.twitter.com/rollacaster\">Twitter</a>.</p>")))

  (t/testing "About"
    (t/is (= (html-str "content/about.org")
             "<h1>Thomas Sojka</h1><figure id=\"org32f227f\" style=\"margin-top:1em;margin-bottom:0;\">  <a href=\"images/me.png\" class=\"hidden md:block\"><img src=\"images/me.png\" alt=\"Picture of Thomas Sojka\" style=\"float: left;margin-right: 3rem;border-radius: 0.25rem;\" ></a></figure><p>Hi üëã</p><p>My name is Thomas, I am a programmer living in Munich.</p><p>I am working at <a href=\"https://comsystoreply.de/\">comSysto</a> where I write business applications for <a href=\"https://comsystoreply.de/referenzen\">various projects</a>. Before that I studied Information Systems at <a href=\"https://www.tum.de/en/\">TUM</a>.</p><p>I am interested in <a href=\"https://www.youtube.com/playlist?list=PLB3sLatZtqYms9T85gf_PTyneg1SLvsEa\">Data</a> <a href=\"https://medium.com/nightingale/steal-like-a-data-visualiser-2ec7fb470896?source=friends_link&amp;sk=8ab6fa936d6e61dbdec2c2a7f607d1a0\">Viz</a>, <a href=\"https://www.youtube.com/watch?v=juMLwOTxnvw\">Functional</a> <a href=\"https://www.youtube.com/watch?v=juMLwOTxnvw\">Programming</a> and <a href=\"https://rollacaster.github.io/sketches/\">art</a> <a href=\"https://twitter.com/rollacaster/status/1351486650992439296\">with</a> <a href=\"https://fire-hands.now.sh/\">code</a>.</p><p>You can find me on <a href=\"https://twitter.com/rollacaster\">Twitter</a>, <a href=\"https://github.com/rollacaster\">GitHub</a>, <a href=\"https://www.youtube.com/channel/UCBSMA2iotgxbWPSLTFeUt9g\">YouTube</a> or contact me via <a href=\"mailto:contact@thomas-sojka.tech\">mail</a>.</p><figure id=\"org32f227f\">  <a href=\"images/me.png\" class=\"md:hidden\" alt=\"Picture of Thomas Sojka\"><img src=\"images/me.png\" alt=\"Picture of Thomas Sojka\" style=\"margin-top:3rem;border-radius: 0.25rem;\"></a></figure>")))

  (t/testing "Creating elisp packages"
    (t/is (= (html-str "content/creating-elisp-packages.org")
             "<h1>Creating elisp packages</h1><p><img src=\"intro.png\" /></p><p>Last week my first <code>elisp</code> package <a href=\"elcontext.html\">elcontext</a> was published on <a href=\"https://melpa.org/#/elcontext\">melpa</a>. It was the first time I have published a non-<code>JavaScript</code> package. Now I would like to share the differences between the <code>elisp</code> and the <code>JavaScript</code> ecosystem I experienced.</p><h3>Learning elisp</h3><p>The first step for creating a package is obviously to learn <code>elisp</code>. Resources which helped me were the <a href=\"https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html\">Introduction to Programming in Emacs Lisp</a>, the <a href=\"https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html\">Emacs Lisp Reference Manual</a> and <a href=\"http://ergoemacs.org/emacs/elisp.html\">Practical Emacs Lisp</a>. A big difference to my usual <code>JavaScript</code> development experience was Emacs‚Äô built-in help system. I discovered many useful <code>elisp</code> snippets in other packages by browsing through their help buffers and sources. It is important to know many <code>elisp</code> packages and to learn from their code since there are fewer online resources about <code>elisp</code> compared to <code>JavaScript</code>.</p><p>Writing lisp was intimidating at first but <a href=\"https://melpa.org/#/paredit\">paredit</a> was a great help to stay sane with hordes of parentheses. The <a href=\"http://danmidwood.com/content/2014/11/21/animated-paredit.html\">Animated Guide to Paredit</a> and <a href=\"http://emacsrocks.com/e14.html\">Emacs Rocks!</a> are great introductions for paredit. Today I cannot imagine writing any code (including <code>JavaScript</code>) without slurping &amp; barfing.</p><p><img src=\"melpa.png\" /></p><p>After writing <a href=\"elcontext.html\">elcontext</a> I published it on <a href=\"https://melpa.org/#/\">melpa</a> which is elisp‚Äôs equivalent to <a href=\"https://www.npmjs.com/\">npm</a>. Instead of a one simple <code>npm publish</code> you have to perform several steps for melpa. First, you need to use <a href=\"https://github.com/purcell/package-lint\">package-lint</a> which informs you about common issues of your package. Then, you must run <code>M x checkdoc</code> which verifies a consistent usage of documentation strings. The steps before opening a PR to melpa are to ensure your code byte-compiles cleanly and to test whether you are able to install your package by using melpa locally. Now you can create a recipe that looks similar to this one:</p><pre>(elcontext :repo &quot;rollacaster/elcontext&quot;\n           :fetcher github)</pre><p>After submitting your PR, melpa‚Äôs maintainers review your code and suggest some improvements. I learned a lot about <code>elisp</code> by applying the reviews‚Äô comments and I checked <a href=\"https://github.com/melpa/melpa/pulls\">some other PRs</a> on melpa to learn even more.</p><p>Adding a package to melpa is definitely more work compared to npm but I am also much more confident about the quality of my package.</p><h3>Conclusion</h3><p>Getting out of my usual <code>JavaScript</code> development was a valuable lesson. Looking at other programming languages and communities seems to be one of the fastest ways to evolve as a programmer. I hope I will be doing this at least once a year.</p><h4>Attributions</h4><ul><li>‚Äù<a href=\"https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html\">Emacs Icon</a>‚Äù by <a href=\"https://nicolas.petton.fr/\">Nicolas Petton</a>, used under <a href=\"https://creativecommons.org/licenses/by-sa/4.0/\">CC BY-SA 4.0</a></li><li>‚Äù<a href=\"http://www.softicons.com/business-icons/ecommerce-and-business-icons-by-designcontest.com/packaging-icon\">Packaging Icon</a>‚Äù by <a href=\"http://www.softicons.com/designers/designcontest.com\">DesignContest.com</a>, used under <a href=\"https://creativecommons.org/licenses/by/3.0/\">CC BY</a></li></ul>")))

  (t/testing "How to grow a tree with clojure.zip"
    (t/is (= (html-str "content/how-to-grow-a-tree.org")
             "<h1>How to grow a tree with clojure.zip</h1><p>This is a post about my journey to build <a href=\"https://github.com/rollacaster/org-parser-tree\">org-parser-tree</a>. As the name suggests, it is a parser that builds a Clojure tree structure from an org file. I would like to share some techniques that helped me creating this parser.</p><h2>The Challenge</h2><p>I had two projects which needed a parser for org files.</p><p>The first one is my journal, a giant org file where I jot down what I read, who I meet, what I watch and anything else that comes to my mind. Each year I calculate annual statistics, such as how many blogs I read, how many people I met and how often I met them, etc.</p><p>The second project is my personal website whose contents are defined in an org file. Each entry in this tree is a category e.g. a blog post, a talk or a course and these entries must be transformed to HTML.</p><p>In order to automate the creation of these two projects I needed the parser.</p><h3>Org files</h3><p>If you have never seen an org file, here is an example:</p><pre> * Headline\n ** Sub Headline\n *** Sub Sub Headline\n *** Sub Sub Headline 2</pre><p>It is very similar to a Markdown file but instead of using <code>#</code> to create headers you use <code>*</code> and there are a <a href=\"https://orgmode.org/\">variety of additional features</a> for org files.</p><h2>Growing trees without clojure.zip</h2><p>I stumbled across the <a href=\"https://github.com/200ok-ch/org-parser\">org-parser</a> project. Currently it converts each line of an org file and returns a flat sequence of Clojure data structure. In the future <a href=\"https://github.com/200ok-ch/org-parser\">org-parser</a> will allow to output a format with structure information of the org file, but this feature is not implemented yet. So I decided to create a quick and dirty version for myself.</p><p>My first attempt was to create a recursive function to build up the tree. Although I was already aware about the <a href=\"https://clojure.github.io/clojure/clojure.zip-api.html\">clojure.zip</a> API from this really great talk: <a href=\"https://lambdaisland.com/blog/2018-11-26-art-tree-shaping-clojure-zip\">The Art of Tree Shaping</a>, I decided to try it first without zippers because I had never used them before and I wanted to do a quick and dirty version.</p><blockquote><p><b>Hint:</b> Later in this post we&apos;ll be using zippers and I am not going to explain that in detail because <a href=\"https://lambdaisland.com/blog/2018-11-26-art-tree-shaping-clojure-zip\">The Art of Tree Shaping</a> is already a great explanation, so I really recommend you watch that talk.</p></blockquote><p>I built a working recursive version, but I wasn&apos;t really happy with the code. I did some research and found the blog post <a href=\"https://vincent.404.taipei/clojure/building-trees-with-and-without-zippers/\">Building trees with and without zippers</a>. The author of that post had the exact same journey as me and shared his solution, building a tree with recursion and building a tree with zippers. The zipper version looked much nicer, so I decided to follow his advice and I started to use zippers as well. Here is my approach that allowed me to finish this task.</p><h2>How to grow a tree</h2><h3>Define minimal source &amp; target data structure</h3><p>Defining clear goals for your data transformation tasks helps a lot. For me it looked like this:</p><h4>Source</h4><pre>  (def source &quot;* Headline\n  ** Sub Headline\n  *** Sub Sub Headline\n  *** Sub Sub Headline 2&quot;)</pre><h4>Target</h4><pre>  (def target\n    {:title &quot;Headline&quot;\n     :children [{:title &quot;Sub Headline&quot;\n                 :children [{:title &quot;Sub Sub Headline&quot;}\n                            {:title &quot;Sub Sub Headline2&quot;}]}]})</pre><p>During development, my source and target data structure are always visible to help me stay on track.</p><h3>Create a fast feedback loop</h3><p>After the plan is set, it helps to know the current progress as well. A fast feedback loop can be achieved easily in Clojure, you can send your current code to your <a href=\"https://clojure.org/guides/repl/introduction\">REPL</a> and inspect the results to get immediate feedback. </p><p>If your results are a big nested data structure, it is difficult to inspect the a textual representation. There are visual tools like <a href=\"https://github.com/cognitect-labs/REBL-distro\">REBL</a> or <a href=\"https://github.com/vlaaad/reveal\">Reveal</a> that can help to visualize any Clojure data structure from your <a href=\"https://clojure.org/guides/repl/introduction\">REPL</a> in various representations. However, instead of using a general purpose tool to visualize my tree, I decided to use <a href=\"https://github.com/ztellman/rhizome\">Rhizome</a> because it fits my use case better. It is a tree visualization library that I set up with my target data structure as following:</p><pre>  (rhizome/view-tree (comp sequential? :children) :children\n                     target\n                     :node-&gt;descriptor (fn [n] {:label (:title n)}))</pre><p><code>view-tree</code> expects a function that checks if a node has a branch, an accessor for the branch and the actual data structure to be visualized. Additionally, I provided a function for <code>node-&gt;descriptor</code> so that each node  in my tree has a label. When I send my target data structure to the <a href=\"https://clojure.org/guides/repl/introduction\">REPL</a>, a new window opens:</p><p><img alt=\"file:~/projects/thomas-sojka-tech/src/images/tree.png\" src=\"images/tree.png\" /></p><p>Now the feedback loop is ready, whenever I change something in the source data structure I can inspect as text or with <a href=\"https://github.com/ztellman/rhizome\">Rhizome</a>.</p><p>Setting up a proper feedback loop is a lot of additional work which you don&apos;t spend working on your actual problem (in this case, parsing a tree). But I think that this time is really well spent. Using fast feedback loops is my secret ingredient to stay focused, motivated and allows discovering edge cases quickly. I can&apos;t prove it, but to me it feels like after half an hour of coding on a problem, a proper feedback loop speeds up the development significantly compared to working on the problem without fast feedback.</p><h3>Create the zipper</h3><p>It&apos;s time to start with the actual problem: creating a zipper for the tree data structure. The <a href=\"https://clojure.github.io/clojure/clojure.zip-api.html\">clojure.zip</a> API is very similar to <a href=\"https://github.com/ztellman/rhizome\">Rhizome</a>, the code to create a zipper looks like this:</p><pre>  (zip/zipper (comp sequential? :children)\n              :children\n              (fn [node children] (assoc node :children children))\n              {:title &quot;root&quot; :stars &quot;&quot; :children []})</pre><p>Again, you need to provide a function to check for a branch and to access the branch. The next parameter is new, it provides a function to create a new node with children. The last parameter is the root node.  </p><p>Now I can set up a loop using <code>reduce</code> to process the flat sequence of lines from <a href=\"https://github.com/200ok-ch/org-parser\">org-parser</a> of my source data structure:</p><pre>  (reduce\n     process-line\n     (z/zipper (comp sequential? :children)\n               :children\n               (fn [node children] (assoc node :children children))\n               {:title &quot;root&quot; :level 0 :children []})\n     (org-parser/org source))</pre><p><code>process-line</code> is called for each parsed line of the source data structure with the zipper and the actual line.</p><h3>Iterate &amp; enjoy</h3><p>The only thing left is the implementation of <code>process-line</code>. This involves three steps:</p><h4>Transform an <a href=\"https://github.com/200ok-ch/org-parser\">org-parser</a> line to match the target structure</h4><p>This is a great opportunity to reuse everything we have learned so far, the source data structure from <a href=\"https://github.com/200ok-ch/org-parser\">org-parser</a> is:</p><pre>[:head-line [:stars &quot;*&quot;] [:title &quot;Headline&quot;]]</pre><p>and the target:</p><pre>{:title &quot;Headline&quot;, :level 1}</pre><p>So setup a feedback loop and iterate, eventually you will come up with something similar to this:</p><pre>  (defn transform-line [[_ &amp; [[_ stars] [_ &amp; title] _]]]\n    {:title (str/join &quot; &quot; title)\n     :level (count stars)})</pre><h4>Place the parsed line in the tree</h4><p>As already mentioned, I won&apos;t explain the <a href=\"https://clojure.github.io/clojure/clojure.zip-api.html\">clojure.zip</a> API in detail, since <a href=\"https://lambdaisland.com/blog/2018-11-26-art-tree-shaping-clojure-zip\">The Art of Tree Shaping</a> is already a really great introduction.</p><p>So let&apos;s place one parsed line in the zipper. I bet you know what&apos;s happening next... source data structures:</p><pre>  ;; zipper\n  (z/zipper (comp sequential? :children)\n            :children\n            (fn [node children] (assoc node :children children))\n            {:title &quot;root&quot; :level 0 :children []})\n  ;; one parsed line\n  {:title &quot;Headline&quot;, :level 1}</pre><p>target data structure:</p><pre>  {:title &quot;root&quot;,\n   :level 0,\n   :children [{:title &quot;Headline&quot;, :level 1, :children []}]}</pre><p>After a few iterations you should get something similar to:</p><pre>  (defn place-in-tree [org-tree {:keys [level] :as headline}]\n    (let [previous-level (:level (z/node org-tree))\n          current-level level\n          new-node (merge headline {:children []})]\n      (cond\n        (= previous-level current-level) ;; no new level found\n        (-&gt; org-tree\n            (z/insert-right new-node) ;; we add a sibling\n            z/rightmost) ;; Move location to the right of the new node\n        :else ;; new level found\n        (-&gt; org-tree\n            (z/append-child new-node) ;; we add a child\n            z/down ;; Move location down since it&apos;s a new level\n            z/rightmost)))) ;; Move location to the right of the new node</pre><h4>Putting it all together in <code>process-line</code></h4><p>Now we&apos;ve build all parts for the parser, next we need to combine everything. The first step is to transform each line from <a href=\"https://github.com/200ok-ch/org-parser\">org-parser</a> and then place it in the tree so <code>process-tree</code> looks like this:</p><pre>  (defn process-line [tree org-parser-line]\n    (-&gt;&gt; org-parser-line\n         transform-line\n         (place-in-tree tree)))</pre><p>and putting it together we get</p><pre>  (-&gt;&gt; (org-parser/org source)\n       (drop 1) ;; org-parser outputs one item we don&apos;t need\n       (reduce\n        process-line\n        (z/zipper (comp sequential? :children)\n                  :children\n                  (fn [node children] (assoc node :children children))\n                  {:title &quot;root&quot; :level 0 :children []}))\n       z/root) ;; builds the tree data structure</pre><h2>Conclusion</h2><p>And that&apos;s how to grow a tree in Clojure. There are still some bugs and missing features in this minimal implementation (e.g. what happens if your org-file reduces its level), but if your feedback loops are in place you can fix this. If you don&apos;t want to grow a tree by yourself, you can use <a href=\"https://github.com/rollacaster/org-parser-tree\">org-parser-tree</a>. Checkout the source code to learn how to extend the tree creation with <a href=\"https://clojure.org/reference/multimethods\">Multimethods</a>.</p>"))))
